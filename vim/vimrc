" Preamble -------------------------------------------------------------------

filetype on
filetype plugin on  " Use the file type plugins
set nocompatible    " Use Vim defaults instead of 100% Vi compatibility

" Basic options --------------------------------------------------------------

set encoding=utf-8
syntax on         " Syntax highlighting
set modelines=0   " CVE-2007-2438
set autoindent    " Always set autoindenting ON
set showmode
set showcmd
set hidden        " Hide buffer instead of closing them
set visualbell
set noerrorbells  " Don't make noise
set ofu=syntaxcomplete#Complete  " Turn ON omnicompletion
set ttyfast
set ruler                       " Show the cursor position
set backspace=indent,eol,start  " More powerful backspacing
set number                      " Show absolute line numbers
set relativenumber              " Show relative line numbers
set laststatus=2                " Always display the status line, even if only
                                " one window is displayed
set history=1000                " Keep 1000 lines of history
set list
"set listchars=tab:»\ ,trail:∙,extends:#,nbsp:∙,eol:¶
set listchars=tab:►\ ,trail:∙,extends:#,nbsp:∙,eol:¶
set showbreak=┼
set fillchars=diff:░
set shell=/bin/bash
set lazyredraw   " Do not redraw while running macros (faster)
set matchtime=3  " Blink matching chars for 3 seconds
set splitbelow
set splitright
set shiftround
set autoread
set title  " Change the terminal's title
set cm=blowfish2
set dictionary=/usr/share/dict/words
set backupskip=/tmp/*,/private/tmp/*  " Make Vim able to edit crontab files
                    " again

" Resize splits when the window is resized
au VimResized * exe "normal! \<c-w>="

let maplocalleader = "\\"
let mapleader = " "
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'
set mousehide    " Hide the mouse cursor when typing
set mouse=a      " Use mouse everywhere
set tags=tags;/  " ctags, search recursively backwards
set smarttab     " Insert tabs on the start of a line according to
                 " shiftwidth, not tabstop
set copyindent   " Copy the previous indentation on autoindenting
                 " sensitive otherwise
set switchbuf=useopen,usetab  " Jump to the first open window that
                              " contains the specified buffer (if there is
                              " one) & also consider windows in other tab
                              " pages
" au BufRead,BufNewFile *.txt setlocal spell  " Turn on spell check for .txt
                                              " files

" Colors ---------------------------------------------------------------------

set colorcolumn=80
set t_Co=256  " Explicitly tell vim that the terminal supports 256 colors
colorscheme badwolf

" Tabs, spaces, wrapping -----------------------------------------------------

set tabstop=4      " The width of a TAB
set shiftwidth=4   " Indents will have a width of 4
set softtabstop=4  " Sets the number of columns for a TAB
set expandtab
set nowrap
set textwidth=80
set formatoptions=qrn1

" Wild menu completion -------------------------------------------------------

set wildmenu
set wildmode=list:longest,full

set wildignore+=.hg,.git,.svn      " Version control
set wildignore+=*.aux,*.out,*.toc  " LaTeX intermediate
                                   " files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg    " Binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest  " compiled object files
set wildignore+=*.spl                             " compiled spelling word
                                                  " lists
set wildignore+=*.sw?       " Vim swap files
set wildignore+=*.DS_Store  " OSX bullshit
set wildignore+=*.luac      " Lua byte code
set wildignore+=migrations  " Django migrations
set wildignore+=*.pyc       " Python byte code

" Backups --------------------------------------------------------------------

set undofile
set swapfile
set undoreload=10000  " Save whole buffer for undo when reloading it
set undodir=~/.vim/undodir
set dir=~/.vim/backup
set backupdir=~/.vim/backup

" Searching and movement -----------------------------------------------------

set ignorecase      " Ignore case when searching
set wildignorecase  " When set case is ignored when completing file names
                    " and directories

set smartcase    " Ignore case if search pattern is all lowercase
set incsearch    " Show search matches as you type
set showmatch
set hlsearch     " Highlight the last searched term
set gdefault     " The substitute flag 'g' is default on
set scrolloff=3  " Minimal number of screen lines to keep above and below
                 " the cursor
nnoremap <silent> gD gDzt
nnoremap <silent> [[ [[zt
nnoremap <silent> ]] ]]zt
" Keep search matches in the middle of the window and pulse the line when
" moving to them
nnoremap <silent> n nzzzv:call PulseCursorLine()<CR>
nnoremap <silent> N Nzzzv:call PulseCursorLine()<CR>

" ----------------------------------------------------------------------------
" GUNDO
" ----------------------------------------------------------------------------

if has('python3')
    let g:gundo_prefer_python3 = 1
endif
nnoremap <silent> <F5> :GundoToggle<CR>

" ----------------------------------------------------------------------------
" CTRL-P
" ----------------------------------------------------------------------------

let g:ctrlp_use_caching = 0
let g:ctrlp_max_files = 0
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']
let g:ctrlp_working_path_mode = 0

" ----------------------------------------------------------------------------
" TAGBAR
" ----------------------------------------------------------------------------

let g:tagbar_ctags_bin='/usr/bin/ctags'  " Proper Ctags locations
let g:tagbar_width=30       " Default is 40, seems too wide
let g:tagbar_left = 1       " Display panel on the left
let g:tagbar_autofocus = 1  " Move the cursor to the Tagbar
let g:tagbar_autoclose = 1  " automatically close when jump
nnoremap <silent> <F6> :TagbarToggle<CR>

" ----------------------------------------------------------------------------
" MAN PAGES
" ----------------------------------------------------------------------------

runtime ftplugin/man.vim
" Open a man page for the word under the cursor
nmap K :Man <cword><CR>

" ----------------------------------------------------------------------------
" FOLDING SETTINGS
" ----------------------------------------------------------------------------

"set foldmethod=indent  " fold based on indent
"set foldnestmax=10     " deepest fold is 10 levels
"set nofoldenable       " dont fold by default
"set foldlevel=1

" ----------------------------------------------------------------------------

if has('autocmd')
    autocmd BufNewFile,BufRead *.log,*.html,*.properties setlocal nowrap
    autocmd BufNewFile,BufRead *.txt setlocal wrap
    autocmd filetype tex setlocal spell
    autocmd filetype xsd,xsl,xslt,xml setlocal softtabstop=2 tabstop=2 shiftwidth=2
    autocmd filetype html,htmldjango setlocal softtabstop=2 tabstop=2 shiftwidth=2
    autocmd InsertLeave * if pumvisible() == 0|pclose|endif
    " If doing a diff. Upon writing changes to file, automatically update
    " the differences
    autocmd BufWritePost * if &diff == 1 | diffupdate | endif
    autocmd BufRead *.tag set syntax=jsp
endif
set pastetoggle=<F2>
" Use Q for formatting the current paragraph (or selection)
vnoremap <silent> Q gq
nnoremap <silent> Q gqip
let g:SuperTabDefaultCompletionType = "context"

nnoremap ; :
vnoremap ; :

" ----------------------------------------------------------------------------
" OTHER SHORTCUTS
" ----------------------------------------------------------------------------

" strip all trailing whitespace in the current file
nnoremap <silent> <leader>W :%s/\s\+$//<CR>:let @/=''<CR>
" reselect the text that was just pasted
nnoremap <leader>v V`]
" save file you didn't open with root privileges
cmap w!! w !sudo tee % >/dev/null
nnoremap <silent> Y y$

" buffer navigation
nnoremap <silent> <C-J> :bprevious<CR>
nnoremap <silent> <C-K> :bnext<CR>
nnoremap <silent> <F12> :bdelete<CR>
nnoremap <silent> <leader><F12> :bwipe<CR>
nnoremap <silent> <leader>n :cnext<CR>
nnoremap <silent> <leader>N :cprevious<CR>

" scroll 20 characters to the right
nnoremap <silent> <C-L> 20zl
" scroll 20 characters to the left
nnoremap <silent> <C-H> 20zh

nnoremap <leader>r :tag

" replace word
nnoremap <silent> <leader>s "_diwPb

" disable mouse wheel while in insert mode
inoremap <ScrollWheelUp> <Nop>
inoremap <ScrollWheelDown> <Nop>

inoremap jj <Esc>

" search selected text
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>

" update and go to buffer end
nnoremap <silent> <leader>u :e<CR>G

" split vertically
nnoremap <C-\> <C-W>v

nnoremap <silent> <leader>d :windo diffthis<CR>
nnoremap <silent> <leader>o :windo diffoff<CR>

" make < > shifts keep selection
vnoremap < <gv
vnoremap > >gv

" Clipboard management  ------------------------------------------------------

vnoremap <silent> ,y "+y
nnoremap <silent> ,y "+y
vnoremap <silent> ,p "+p
nnoremap <silent> ,p "+p
vnoremap <silent> ,P "+P
nnoremap <silent> ,P "+P

" windows
"vnoremap <silent> ,y :call Putclip(visualmode(), 1)<CR>
"nnoremap <silent> ,y :call Putclip('n', 1)<CR>
function! Putclip(type, ...) range
  let sel_save = &selection
  let &selection = "inclusive"
  let reg_save = @@
  if a:type == 'n'
    silent exe a:firstline . "," . a:lastline . "y"
  elseif a:type == 'c'
    silent exe a:1 . "," . a:2 . "y"
  else
    silent exe "normal! `<" . a:type . "`>y"
  endif
  "call system('putclip', @@)
  "As of Cygwin 1.7.13, the /dev/clipboard device was added to provide
  "access to the native Windows clipboard. It provides the added benefit
  "of supporting utf-8 characters which putclip currently does not. Based
  "on a tip from John Beckett, use the following:
  call writefile(split(@@,"\n"), '/dev/clipboard')
  let &selection = sel_save
  let @@ = reg_save
endfunction

" Pulse ----------------------------------------------------------------------

function! PulseCursorLine()
    let current_window = winnr()

    windo set nocursorline
    execute current_window . 'wincmd w'

    setlocal cursorline

    redir => old_hi
    silent execute 'hi CursorLine'
    redir END
    let old_hi = split(old_hi, '\n')[0]
    let old_hi = substitute(old_hi, 'xxx', '', '')

    hi CursorLine guibg=#2a2a2a ctermbg=233
    redraw
    sleep 20m

    hi CursorLine guibg=#333333 ctermbg=235
    redraw
    sleep 20m

    hi CursorLine guibg=#3a3a3a ctermbg=237
    redraw
    sleep 20m

    hi CursorLine guibg=#444444 ctermbg=239
    redraw
    sleep 20m

    hi CursorLine guibg=#3a3a3a ctermbg=237
    redraw
    sleep 20m

    hi CursorLine guibg=#333333 ctermbg=235
    redraw
    sleep 20m

    hi CursorLine guibg=#2a2a2a ctermbg=233
    redraw
    sleep 20m

    execute 'hi ' . old_hi

    windo set nocursorline
    execute current_window . 'wincmd w'
endfunction

" Find file in current directory and edit it ---------------------------------

function! Find(name)
  let l:list=system("find . -type f -iname '*".a:name."*' | grep -v \".svn\" | grep -v \".class\"|  perl -ne 'print \"$.\\t$_\"'")
  let l:num=strlen(substitute(l:list, "[^\n]", "", "g"))
  if l:num < 1
    echo "'".a:name."' not found"
    return
  endif
  if l:num != 1
    echo l:list
    let l:input=input("Which ? (CR=nothing)\n")
    if strlen(l:input)==0
      return
    endif
    if strlen(substitute(l:input, "[0-9]", "", "g"))>0
      echo "Not a number"
      return
    endif
    if l:input<1 || l:input>l:num
      echo "Out of range"
      return
    endif
    let l:line=matchstr("\n".l:list, "\n".l:input."\t[^\n]*")
  else
    let l:line=l:list
  endif
  let l:line=substitute(l:line, "^[^\t]*\t./", "", "")
  execute ":e ".l:line
endfunction
command! -nargs=1 F :call Find("<args>")

" Highlight duplicate lines --------------------------------------------------

function! HighlightRepeats() range
  let lineCounts = {}
  let lineNum = a:firstline
  while lineNum <= a:lastline
    let lineText = getline(lineNum)
    if lineText != ""
      let lineCounts[lineText] = (has_key(lineCounts, lineText) ? lineCounts[lineText] : 0) + 1
    endif
    let lineNum = lineNum + 1
  endwhile
  exe 'syn clear Repeat'
  for lineText in keys(lineCounts)
    if lineCounts[lineText] >= 2
      exe 'syn match Repeat "^' . escape(lineText, '".\^$*[]') . '$"'
    endif
  endfor
endfunction

command! -range=% HighlightRepeats <line1>,<line2>call HighlightRepeats()

"au bufreadpost,filereadpost *.class setlocal filetype=java |  %!jad -noctor -f -ff -i -p %
au bufreadpost,filereadpost *.class setlocal filetype=java |  %!cfr %

function! ClearFile()
  execute "norm! ggVGd"
endfunction
command! -nargs=0 D :call ClearFile()
